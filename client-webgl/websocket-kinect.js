// Generated by CoffeeScript 1.12.7
(function() {
  $(function() {
    var animate, bgColour, camT, camYRange, camZ, camZRange, camera, connect, currentOutArrayIdx, dataCallback, doCamPan, doCamZoom, down, drawControl, dvp, dynaPan, fgColour, h, i, inputH, inputW, j, k, kvp, l, len, m, outArrays, pLen, pMaterial, params, particle, particleSystem, particles, prevOutArrayIdx, projector, pvs, qbl, qbr, qtl, qtr, rawDataLen, ref, ref1, ref2, ref3, ref4, ref5, renderer, scene, seenKeyFrame, setSize, startCamPan, stats, stopCamPan, sx, sy, togglePlay, useEvery, v, w, wls, x, xc, y, yc;
    params = {
      stats: 0,
      fog: 1,
      credits: 1,
      ws: "ws://" + window.location.host
    };
    wls = window.location.search;
    ref = wls.substring(1).split('&');
    for (j = 0, len = ref.length; j < len; j++) {
      kvp = ref[j];
      ref1 = kvp.split('='), k = ref1[0], v = ref1[1];
      params[k] = k === 'ws' ? v : parseInt(v);
    }
    if (params.credits) {
      $('#creditOuter').show();
    }
    if (params.stats) {
      stats = new Stats();
      stats.domElement.id = 'stats';
      document.body.appendChild(stats.domElement);
    }
    bgColour = 0x000000;
    fgColour = 0xffffff;
    inputW = 632;
    inputH = 480;
    useEvery = 4;
    w = inputW / useEvery;
    h = inputH / useEvery;
    Transform.prototype.t = Transform.prototype.transformPoint;
    v = function(x, y, z) {
      return new THREE.Vector3(x, y, z);
    };
    renderer = new THREE.WebGLRenderer({
      antialias: true
    });
    camera = new THREE.PerspectiveCamera(60, 1, 1, 10000);
    dvp = (ref2 = window.devicePixelRatio) != null ? ref2 : 1;
    setSize = function() {
      renderer.setSize(window.innerWidth * dvp, window.innerHeight * dvp);
      renderer.domElement.style.width = window.innerWidth + 'px';
      renderer.domElement.style.height = window.innerHeight + 'px';
      camera.aspect = window.innerWidth / window.innerHeight;
      return camera.updateProjectionMatrix();
    };
    setSize();
    $(window).on('resize', setSize);
    document.body.appendChild(renderer.domElement);
    renderer.setClearColor(bgColour, 1.0);
    renderer.clear();
    projector = new THREE.Projector();
    scene = new THREE.Scene();
    scene.add(camera);
    if (params.fog) {
      scene.fog = new THREE.FogExp2(bgColour, 0.00033);
    }
    pMaterial = new THREE.PointsMaterial({
      color: fgColour,
      size: useEvery * 3.5
    });
    particles = new THREE.Geometry();
    for (y = l = 0, ref3 = h; 0 <= ref3 ? l < ref3 : l > ref3; y = 0 <= ref3 ? ++l : --l) {
      for (x = m = 0, ref4 = w; 0 <= ref4 ? m < ref4 : m > ref4; x = 0 <= ref4 ? ++m : --m) {
        xc = (x - (w / 2)) * useEvery * 2;
        yc = ((h / 2) - y) * useEvery * 2;
        particle = v(xc, yc, 0);
        particle.usualY = yc;
        particles.vertices.push(particle);
      }
    }
    particleSystem = new THREE.Points(particles, pMaterial);
    scene.add(particleSystem);
    togglePlay = function() {};
    drawControl = function(playing) {
      var ctx, cvs;
      cvs = $('#control')[0];
      ctx = cvs.getContext('2d');
      ctx.fillStyle = '#fff';
      if (playing) {
        return ctx.fillRect(0, 0, cvs.width, cvs.height);
      } else {
        ctx.clearRect(0, 0, cvs.width, cvs.height);
        ctx.moveTo(0, 0);
        ctx.lineTo(cvs.width, cvs.height / 2);
        ctx.lineTo(0, cvs.height);
        return ctx.fill();
      }
    };
    drawControl(false);
    down = false;
    dynaPan = 0;
    sx = sy = 0;
    camZRange = [2000, 200];
    camZ = 880;
    camYRange = [-600, 600];
    camT = new Transform();
    animate = function() {
      var ref5;
      renderer.clear();
      ref5 = camT.t(0.01 * camZ * dynaPan, camZ), camera.position.x = ref5[0], camera.position.z = ref5[1];
      camera.lookAt(scene.position);
      renderer.render(scene, camera);
      window.requestAnimationFrame(animate, renderer.domElement);
      if (params.stats) {
        return stats.update();
      }
    };
    animate();
    startCamPan = function(ev) {
      down = true;
      sx = ev.clientX;
      return sy = ev.clientY;
    };
    $(renderer.domElement).on('mousedown', startCamPan);
    stopCamPan = function() {
      return down = false;
    };
    $(renderer.domElement).on('mouseup', stopCamPan);
    doCamPan = function(ev) {
      var camY, dx, dy, rotation;
      if (down) {
        dx = ev.clientX - sx;
        dy = ev.clientY - sy;
        rotation = dx * 0.0005 * Math.log(camZ);
        camT.rotate(rotation);
        camY = camera.position.y;
        camY += dy * 3;
        if (camY < camYRange[0]) {
          camY = camYRange[0];
        }
        if (camY > camYRange[1]) {
          camY = camYRange[1];
        }
        camera.position.y = camY;
        sx += dx;
        return sy += dy;
      }
    };
    $(renderer.domElement).on('mousemove', doCamPan);
    doCamZoom = function(ev, d, dX, dY) {
      camZ -= dY * 40;
      camZ = Math.max(camZ, camZRange[1]);
      return camZ = Math.min(camZ, camZRange[0]);
    };
    $(renderer.domElement).on('mousewheel', doCamZoom);
    seenKeyFrame = null;
    qtl = qtr = qbl = qbr = null;
    pvs = particles.vertices;
    console.log(pvs);
    pLen = pvs.length;
    rawDataLen = 5 + pLen;
    outArrays = (function() {
      var n, results;
      results = [];
      for (i = n = 0; n <= 1; i = ++n) {
        results.push(new Uint8Array(new ArrayBuffer(rawDataLen)));
      }
      return results;
    })();
    ref5 = [0, 1], currentOutArrayIdx = ref5[0], prevOutArrayIdx = ref5[1];
    dataCallback = function(e) {
      var aByte, byteIdx, bytes, depth, inStream, keyFrame, n, o, outStream, pIdx, prevBytes, pv, ref6, ref7, ref8, ref9;
      ref6 = [prevOutArrayIdx, currentOutArrayIdx], currentOutArrayIdx = ref6[0], prevOutArrayIdx = ref6[1];
      inStream = LZMA.wrapArrayBuffer(new Uint8Array(e.data));
      outStream = LZMA.wrapArrayBuffer(outArrays[currentOutArrayIdx]);
      LZMA.decompress(inStream, inStream, outStream, rawDataLen);
      bytes = outStream.data;
      prevBytes = outArrays[prevOutArrayIdx];
      keyFrame = bytes[0];
      if (!(keyFrame || seenKeyFrame)) {
        return;
      }
      seenKeyFrame = true;
      ref7 = [bytes[1], bytes[2], bytes[3], bytes[4]], qtl = ref7[0], qtr = ref7[1], qbl = ref7[2], qbr = ref7[3];
      dynaPan = dynaPan * 0.9 + ((qtr + qbr) - (qtl + qbl)) * 0.1;
      pIdx = 0;
      byteIdx = 5;
      for (y = n = 0, ref8 = h; 0 <= ref8 ? n < ref8 : n > ref8; y = 0 <= ref8 ? ++n : --n) {
        for (x = o = 0, ref9 = w; 0 <= ref9 ? o < ref9 : o > ref9; x = 0 <= ref9 ? ++o : --o) {
          pv = pvs[pIdx];
          aByte = bytes[byteIdx];
          if (!keyFrame) {
            aByte = bytes[byteIdx] = (prevBytes[byteIdx] + aByte) % 256;
          }
          if (aByte === 255) {
            pv.y = -5000;
          } else {
            pv.y = pv.usualY;
            depth = 128 - aByte;
            pv.z = depth * 10;
          }
          pIdx += 1;
          byteIdx += 1;
        }
      }
      particleSystem.geometry.__dirtyVertices = true;
      return particleSystem.geometry.verticesNeedUpdate = true;
    };
    connect = function() {
      var reconnectDelay, ws;
      reconnectDelay = 10;
      console.log("Connecting to " + params.ws + " ...");
      ws = new WebSocket(params.ws);
      ws.binaryType = 'arraybuffer';
      seenKeyFrame = false;
      ws.onopen = function() {
        return console.log('Connected');
      };
      ws.onclose = function() {
        console.log("Disconnected: retrying in " + reconnectDelay + "s");
        return setTimeout(connect, reconnectDelay * 1000);
      };
      return ws.onmessage = dataCallback;
    };
    return connect();
  });

}).call(this);
